{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Database Schema and Implement Role-Based Auth",
        "description": "Set up the foundational database structure using the provided Drizzle schema and configure Supabase for role-based authentication (Breeder, Seeker, Admin).",
        "details": "Take the Drizzle schema from `db/schema.ts`, generate the SQL migration, and apply it to the Supabase PostgreSQL database. Implement sign-up and sign-in logic that correctly assigns a 'role' to the user in the 'users' table. Create RLS policies for the 'users' table allowing users to only access and modify their own data.",
        "testStrategy": "Verify that `drizzle-kit push:pg` or `migrate` runs successfully. Test the sign-up flow for a new seeker and a new breeder, and confirm their roles are correctly set in the database via the Supabase table editor. Ensure a logged-in user cannot fetch data for another user.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Finalize Drizzle Schema and Apply to Supabase Database",
            "description": "Review the existing schema in `db/schema.ts`, ensuring all necessary tables (`users`, `litters`, etc.) and columns (like `users.role`) are correctly defined. Generate the SQL migration files using Drizzle Kit and apply them to the Supabase PostgreSQL database.",
            "dependencies": [],
            "details": "Use `drizzle-kit generate:pg` to create the migration script. Then, use `drizzle-kit push:pg` or a custom migration script to apply the schema changes to the remote Supabase database configured via environment variables. Verify table creation in the Supabase dashboard.",
            "status": "done",
            "testStrategy": "Run the Drizzle Kit commands and ensure they complete without errors. Manually inspect the Supabase database via its web UI to confirm that all tables and columns from `db/schema.ts` have been created correctly."
          },
          {
            "id": 2,
            "title": "Decommission Existing Firebase Authentication Implementation",
            "description": "Systematically remove all Firebase authentication logic from the codebase to prepare for the Supabase migration. This includes removing SDKs, configuration files, and references in UI components.",
            "dependencies": [],
            "details": "Delete `src/lib/firebase/client.ts` and `src/lib/firebase/server.ts`. Uninstall the `firebase` npm package. Go through auth-related components like `src/app/(auth)/login/index.tsx` and remove Firebase-specific function calls (`signInWithEmailAndPassword`, etc.). Remove Firebase-related environment variables from `.env` files.",
            "status": "done",
            "testStrategy": "After removal, the application's login and sign-up pages should be broken or in a clean state, ready for new logic. The app should build without errors related to missing Firebase modules. Run `npm ls firebase` to ensure the package is gone."
          },
          {
            "id": 3,
            "title": "Implement Supabase User Authentication and Session Management",
            "description": "Replace the decommissioned Firebase logic with Supabase for user sign-up, sign-in, sign-out, and session management. This includes creating a Supabase client and integrating it into the auth UI and server-side logic.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create Supabase clients in `src/lib/supabase/client.ts` and `src/lib/supabase/server.ts`. Update `src/pages/signup/index.tsx` to use `supabase.auth.signUp`. On successful sign-up, insert a record into the public `users` table with the user's `id`, `email`, and selected `role`. Update the login page `src/pages/login/index.tsx`  to use `supabase.auth.signInWithPassword`. Implement session management using Supabase's cookie-based helpers for Next.js.",
            "status": "done",
            "testStrategy": "Test the full sign-up flow for both a 'seeker' and a 'breeder'. Verify that `auth.users` and the public `users` table are populated correctly in Supabase. Test login and logout functionality. Ensure user sessions persist across page reloads."
          },
          {
            "id": 4,
            "title": "Configure Initial Row-Level Security (RLS) Policies",
            "description": "Implement the initial set of Row-Level Security (RLS) policies on core database tables like 'users' and 'litters' to enforce data access rules, ensuring users can only access and modify their own data.",
            "dependencies": [
              1,
              3
            ],
            "details": "In the Supabase SQL editor, enable RLS for the `users` and `litters` tables. For `users`, create policies allowing users to SELECT and UPDATE only their own record (`uid() = id`). For `litters`, allow breeders to CUD their own litters (`uid() = breeder_id`) and all authenticated users to SELECT litters. Policies must be created using SQL statements in a new Supabase migration file.",
            "status": "done",
            "testStrategy": "Log in as a user and use a client-side query to fetch all users; it should only return the current user's data. As a breeder, verify you can create/edit your litters. As a seeker, verify you can read litters but cannot create or edit them. Attempting to update another user's data should result in an RLS violation error."
          },
          {
            "id": 5,
            "title": "Fix Remaining Firebase Authentication References",
            "description": "Update all remaining components that use Firebase authentication hooks (useAuthState, useSignOut) to use the new Supabase authentication system",
            "details": "Search through the codebase for any remaining Firebase authentication references and replace them with Supabase equivalents. Update Header.tsx, UserProfileMenu.tsx, and any other components that still import from 'lib/firebase/client' or use Firebase hooks.",
            "status": "done",
            "dependencies": "",
            "testStrategy": "Run the application and verify that all Firebase authentication hooks are replaced with Supabase equivalents. Verify that the application still functions as expected."
          }
        ]
      },
      {
        "id": 2,
        "title": "Setup React Query and State Management",
        "description": "Establish a robust data fetching and state management foundation by integrating React Query and a global state manager like Zustand.",
        "details": "Install React Query and its devtools. Configure a global QueryClientProvider in the main app layout. Create a centralized factory for query keys to ensure consistency. Set up a Zustand store for managing global UI state and the user session.",
        "testStrategy": "Verify that the React Query devtools are visible in development mode. Create a simple test component that uses a query hook to fetch data and confirms the data is cached and available. Test that a Zustand store can be updated and its state is accessible from different components.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install React Query and Devtools packages",
            "description": "Add `@tanstack/react-query` and `@tanstack/react-query-devtools` to the project's dependencies using npm or yarn.",
            "dependencies": [],
            "details": "Update the `package.json` file by adding the necessary React Query dependencies. Run `npm install` or `yarn add` to install them. This is a foundational step before any configuration.",
            "status": "done",
            "testStrategy": "Verify the presence of `@tanstack/react-query` and `@tanstack/react-query-devtools` in `package.json` and `node_modules`."
          },
          {
            "id": 2,
            "title": "Configure QueryClientProvider globally",
            "description": "Initialize a new `QueryClient` instance with default options and wrap the entire Next.js application with `QueryClientProvider`.",
            "dependencies": [
              1
            ],
            "details": "Create a `QueryClient` instance, potentially in a new file like `src/lib/queryClient.ts` or `src/utils/queryClient.ts`. Configure default options such as `staleTime` and `cacheTime`. Then, integrate `QueryClientProvider` in the root layout file (e.g., `src/app/layout.tsx` or a custom `_app.tsx` if using pages directory) to make React Query available throughout the app. Also, include `ReactQueryDevtools` for development environments.",
            "status": "done",
            "testStrategy": "Verify that React Query Devtools are visible in the browser during development. Create a temporary page with a basic `useQuery` call to ensure the provider is correctly set up and no errors occur."
          },
          {
            "id": 3,
            "title": "Create a centralized query key factory",
            "description": "Implement a utility file that provides a structured and consistent way to define query keys for different data entities.",
            "dependencies": [
              2
            ],
            "details": "Create a new file, for example, `src/lib/queryKeys.ts`, which exports an object or functions to generate unique and descriptive query keys. For instance, `queryKeys.users.all`, `queryKeys.users.detail(userId)`, `queryKeys.profile.all`, `queryKeys.litters.all`, `queryKeys.litters.byBreeder(breederId)`. This ensures type safety and avoids key collisions.",
            "status": "done",
            "testStrategy": "Write unit tests for the query key factory to ensure it generates correct and consistent key structures. Ensure that keys are deterministic for the same inputs."
          },
          {
            "id": 4,
            "title": "Set up Zustand store for global state management",
            "description": "Initialize a Zustand store to manage global application state, including user session information and general UI state.",
            "dependencies": [],
            "details": "Install `zustand`. Create a new file (e.g., `src/stores/useAppStore.ts`). Define the store to hold global states such as `userSession` (e.g., `userId`, `role`, `isAuthenticated`), and UI states like `isSidebarOpen` or `isLoadingOverlayVisible`. Implement actions for updating these states.",
            "status": "done",
            "testStrategy": "Create a temporary component that consumes and modifies the Zustand store state. Verify that changes to the store are reflected across different components without prop drilling. Ensure `userSession` can be updated correctly."
          },
          {
            "id": 5,
            "title": "Develop custom React Query hooks for Supabase integration",
            "description": "Create reusable custom hooks that abstract common data fetching patterns from Supabase using React Query.",
            "dependencies": [
              2,
              3
            ],
            "details": "Develop custom hooks (e.g., `useUserProfile`, `useLitters`, `useBreederProfiles`) in a directory like `src/hooks/queries`. These hooks will encapsulate the logic of fetching data from Supabase using the Supabase client and `useQuery`, `useMutation` from React Query. Utilize the centralized query key factory (from subtask 3) for defining query keys within these hooks.",
            "status": "done",
            "testStrategy": "Implement a simple component that uses one of the new custom hooks (e.g., `useUserProfile`). Verify that data is fetched and displayed correctly. Use React Query Devtools to confirm caching and query states (loading, success, error) are managed as expected. Simulate a data update to test `useMutation` if implemented."
          }
        ]
      },
      {
        "id": 3,
        "title": "Refactor Onboarding Flow to Use Supabase",
        "description": "Migrate the multi-step onboarding process from Firebase to Supabase, ensuring user data is correctly captured in the new Drizzle schema.",
        "details": "Refactor the components in `src/lib/pages/onboarding/` to use Supabase for user session management and data persistence. Replace `useAuthState` with a Supabase equivalent and update the logic that saves user profile information (`name`, `location`, `roles`, `user_breeds`) to write to the new PostgreSQL tables.",
        "testStrategy": "Complete the onboarding flow as a new user. Verify that the user's role, contact details, and initial breed preferences are correctly saved to the 'users' and 'user_breeds' tables in Supabase. Ensure the user session is correctly managed by Supabase throughout the flow.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Restructure Onboarding with Role-Specific Flows",
            "description": "Create separate onboarding directories for breeders and seekers with role-specific components and flows.",
            "dependencies": [],
            "details": "Create `src/lib/pages/onboarding/breeder/` and `src/lib/pages/onboarding/seeker/` directories. Move existing components to appropriate directories and create new role-specific components for unique requirements.",
            "status": "pending",
            "testStrategy": "Verify that the new directory structure exists and components are properly organized by role."
          },
          {
            "id": 2,
            "title": "Update Database Schema for Enhanced Profiles",
            "description": "Add new fields to users and wanted_listings tables to support enhanced onboarding features.",
            "dependencies": [],
            "details": "Add living_situation, experience_level, kennel_name, kennel_location, facility_type to users table. Add preference fields to wanted_listings table.",
            "status": "pending",
            "testStrategy": "Run database migration and verify new columns exist in Supabase tables."
          },
          {
            "id": 3,
            "title": "Create Role-Specific React Query Hooks",
            "description": "Develop hooks for wanted listings, enhanced user profiles, and breed image uploads.",
            "dependencies": [
              2
            ],
            "details": "Create useWantedListings, useCreateWantedListing, useUploadBreedImage, and enhanced useUpdateUserProfile hooks.",
            "status": "pending",
            "testStrategy": "Test hooks individually to ensure they properly interact with the updated database schema."
          },
          {
            "id": 4,
            "title": "Implement Seeker Onboarding Flow",
            "description": "Build complete seeker onboarding with preferences and wanted listing creation.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create SeekerContactDetails, SeekerPreferences, and WantedListing components that save to wanted_listings table.",
            "status": "pending",
            "testStrategy": "Complete seeker onboarding flow and verify wanted_listing is created with all preferences."
          },
          {
            "id": 5,
            "title": "Implement Breeder Onboarding Flow",
            "description": "Build complete breeder onboarding with kennel info and breed image upload.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create BreederContactDetails, BreedSelection, and BreedImages components with image upload functionality.",
            "status": "pending",
            "testStrategy": "Complete breeder onboarding flow and verify kennel information and breed images are properly saved."
          },
          {
            "id": 6,
            "title": "Update Onboarding Router Logic",
            "description": "Modify main onboarding component to route users to appropriate role-specific flows.",
            "dependencies": [
              4,
              5
            ],
            "details": "Update src/lib/pages/onboarding/index.tsx to detect user role and render appropriate flow components.",
            "status": "pending",
            "testStrategy": "Test role detection and routing to ensure users see the correct onboarding flow."
          }
        ]
      },
      {
        "id": 4,
        "title": "Refactor Dashboard Layout and Sidebar for Role-Based Views",
        "description": "Update the main layout and sidebar navigation to dynamically display menu items based on the user's role (Breeder, Seeker, Admin) as defined in the PRD.",
        "details": "Modify the layout components in `src/lib/components/layout/`, particularly `Sidebar.tsx`. The component should fetch the current user's role from the Supabase session and render different navigation links for 'Breeder', 'Seeker', and 'Admin' roles, matching the components outlined in the PRD's MVP Dashboard Summary.",
        "testStrategy": "Log in as a Seeker and verify the sidebar shows links to 'Matches' and 'My Applications'. Log in as a Breeder and verify links for 'Breeds', 'Litters', and 'Inquiries'. Log in as an Admin and verify links for 'Verification' and 'Analytics'.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create 'useUserProfile' Hook to Fetch User Role",
            "description": "Develop a custom React hook `useUserProfile` that fetches the current user's profile data, including their role, from the 'users' table in Supabase. This hook will encapsulate the logic for retrieving the session user and querying for their extended profile.",
            "dependencies": [],
            "details": "Create a new file `src/hooks/useUserProfile.ts`. The hook should use `useUser` from `@supabase/auth-helpers-react` to get the authenticated user's ID and `useSupabaseClient` to query the `users` table for the row matching that ID. It should return the user profile object (or null/undefined during loading/error states) and the user's role.",
            "status": "pending",
            "testStrategy": "Create a test page that uses the hook. Log in as a Breeder and verify the hook returns the full user profile with `role: 'Breeder'`. Test loading and unauthenticated states."
          },
          {
            "id": 2,
            "title": "Define Role-Based Navigation Link Configurations",
            "description": "Create a centralized configuration object or file that defines the navigation links for each user role (Breeder, Seeker, Admin). This will decouple the link data from the rendering logic in the Sidebar component.",
            "dependencies": [],
            "details": "In a new file, e.g., `src/lib/config/navLinks.ts`, define a constant object. This object will have keys for 'SEEKER', 'BREEDER', and 'ADMIN'. Each key will hold an array of link objects, with each object containing `href`, `label`, and an `icon` component.",
            "status": "pending",
            "testStrategy": "Review the created configuration file to ensure it contains distinct, correct navigation links for each of the three roles as specified in the PRD's MVP Dashboard Summary."
          },
          {
            "id": 3,
            "title": "Integrate 'useUserProfile' Hook into DashboardLayout",
            "description": "Modify the main `DashboardLayout.tsx` component to use the new `useUserProfile` hook. This component will be responsible for fetching the user's role and passing it down to its children, specifically the Sidebar.",
            "dependencies": [
              1
            ],
            "details": "In `src/lib/components/layout/DashboardLayout.tsx`, call the `useUserProfile` hook to get the user's role. Pass the retrieved role as a prop to the `<Sidebar />` component. Handle loading states by displaying a layout-level skeleton or spinner.",
            "status": "pending",
            "testStrategy": "Add a `console.log` in `DashboardLayout.tsx` to print the role received from the hook. Log in as a Seeker and verify that 'Seeker' is logged. Check that the layout shows a loading state while the profile is being fetched."
          },
          {
            "id": 4,
            "title": "Refactor Sidebar.tsx to Render Links Dynamically",
            "description": "Update `Sidebar.tsx` to accept the user's role as a prop and dynamically render the appropriate navigation links based on the configuration created in the previous subtask.",
            "dependencies": [
              2,
              3
            ],
            "details": "Modify `src/lib/components/layout/Sidebar.tsx` to accept a `role` prop. Use this prop to look up the correct array of links from the `navLinks` configuration. Map over the retrieved array to render the `<Link>` components. If the `role` prop is null or undefined, render a skeleton version of the navigation.",
            "status": "pending",
            "testStrategy": "Log in as a Seeker and verify the sidebar shows 'Matches' and 'My Applications'. Log in as a Breeder and see 'Breeds', 'Litters', 'Inquiries'. Log in as an Admin and see 'Verification' and 'Analytics'."
          },
          {
            "id": 5,
            "title": "Create Placeholder Pages for New Dashboard Routes",
            "description": "To prevent 404 errors from the new sidebar links, create basic placeholder pages for each new role-specific dashboard route.",
            "dependencies": [
              4
            ],
            "details": "Create files for each new route, such as `src/pages/dashboard/matches.tsx`, `src/pages/dashboard/litters.tsx`, `src/pages/dashboard/verification.tsx`, etc. Each page should be a simple React component that renders an `<h1>` tag with the page title (e.g., 'My Matches') and is wrapped in the `DashboardLayout`.",
            "status": "pending",
            "testStrategy": "After logging in as each role, click every link in the updated sidebar and verify that it navigates to a valid page with the correct title and does not result in a 404 error."
          }
        ]
      },
      {
        "id": 5,
        "title": "Develop User Profile Management Component",
        "description": "Create a shared component for users of all roles to view and edit their profile information, including bio, photo, location, and contact details.",
        "details": "Build a form in Next.js that populates with the current user's data from the 'users' table. Implement an update function that writes changes back to Supabase. Include functionality for uploading a profile photo to Supabase Storage and updating the `profile_photo_url` field. This component should be accessible from a user's dashboard.",
        "testStrategy": "Log in as a user, navigate to the profile page, change the bio and display name, and verify the changes persist after a page refresh. Test the image upload functionality and confirm the new image is displayed. Check the Supabase Storage bucket to ensure the file was uploaded.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Profile Page and Fetch User Data",
            "description": "Create the main page component for user profile management, located at `/settings/profile`. This server component will be responsible for fetching the currently logged-in user's data from the Supabase 'users' table.",
            "dependencies": [],
            "details": "Create the file `src/app/(app)/settings/profile/index.tsx`. Use the `createServerComponentClient` from `@supabase/auth-helpers-nextjs` to fetch user session and profile data (name, bio, location, photo URL). The fetched data will be passed as props to a client component created in a subsequent task.",
            "status": "pending",
            "testStrategy": "Navigate to `/settings/profile` while logged in. Verify the page loads without errors. Log the fetched user data on the server to confirm it's being retrieved correctly."
          },
          {
            "id": 2,
            "title": "Build Profile Form UI Client Component",
            "description": "Develop a client component that displays the user profile form. This component will receive the user's data as props and render a form with fields for display name, bio, and location.",
            "dependencies": [
              1
            ],
            "details": "Create a new client component file, e.g., `src/components/profile/profile-form.tsx`. Use `Chakra UI` components (`Input`, `Textarea`, `Button`, `Label`) to build the form. Populate the form fields with the initial user data passed via props. Use `react-hook-form` and `zod` for form state management and validation, following existing patterns in the codebase.",
            "status": "pending",
            "testStrategy": "Render the component with mock user data. Verify that all form fields display the correct initial values. Check that the form layout is responsive and matches the site's design system."
          },
          {
            "id": 3,
            "title": "Implement API Route for Profile Text Updates",
            "description": "Create a Next.js API route to handle updates for the text-based profile fields (display name, bio, location).",
            "dependencies": [
              2
            ],
            "details": "Create a new api route in `src/pages/api/users/`. The API route will accept form data, validate it using a Zod schema, and use the Supabase client to update the corresponding record in the 'users' table. Connect this action to the `onSubmit` handler of the profile form.",
            "status": "pending",
            "testStrategy": "Log in, change the display name and bio, and submit the form. After a page refresh, the new values should persist. Check the 'users' table in Supabase directly to confirm the update. Test validation by submitting empty or invalid data."
          },
          {
            "id": 4,
            "title": "Add Profile Photo Display and Upload UI",
            "description": "Enhance the profile form to include the user's current profile photo and a file input for uploading a new one. This involves only the UI and client-side state management for the selected file.",
            "dependencies": [
              2
            ],
            "details": "In `profile-form.tsx`, use the `next/image` component to display the current user's avatar using the `profile_photo_url`. Add a styled `<input type='file' accept='image/*' />` for selecting a new photo. Implement client-side logic to show a preview of the selected image before uploading.",
            "status": "pending",
            "testStrategy": "Verify the current profile photo (or a placeholder) is displayed correctly. Select a new image file from your local machine and confirm that a preview of the new image is shown, replacing the old one."
          },
          {
            "id": 5,
            "title": "Implement API Route for Photo Upload and URL Update",
            "description": "Create the server-side logic to handle the profile photo upload to Supabase Storage and update the user's record with the new photo URL.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create a new API route that accepts `FormData`. This API route will: 1. Extract the file from the form data. 2. Upload the file to a designated Supabase Storage bucket (e.g., 'avatars'). 3. Retrieve the public URL of the uploaded file. 4. Update the `profile_photo_url` column in the 'users' table for the current user. Ensure proper error handling for upload failures.",
            "status": "pending",
            "testStrategy": "Log in, upload a new profile picture, and submit. Verify that the new picture is displayed on the profile page after refresh. Check the Supabase Storage 'avatars' bucket to confirm the new file exists. Verify the `profile_photo_url` in the 'users' table has been updated."
          }
        ]
      },
      {
        "id": 6,
        "title": "Build Admin Dashboard: Breeder Verification Panel",
        "description": "Create a secure dashboard page for Admins to review and manage breeder verification requests.",
        "details": "Develop a page accessible only to users with the 'admin' role. This page should fetch and display a list of breeders with `is_verified = false`. For each breeder, the admin should be able to view their submitted `verification_docs` (from `breeder_profiles`) and have 'Approve' and 'Reject' buttons. The 'Approve' action should set `users.is_verified` to true and populate `breeder_profiles.verified_at`.",
        "testStrategy": "Log in as an admin and verify access to the panel. Log in as a breeder/seeker and verify access is denied. Create a test breeder account, submit mock verification data, and use the admin panel to approve the request. Verify the database fields are updated correctly.",
        "priority": "high",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Breeder Dashboard: Breed & Litter Management UI",
        "description": "Implement the core functionality for verified breeders to manage the breeds they offer and create/edit their litters.",
        "details": "Create a dashboard section for breeders. Implement a UI to add/remove breeds from their profile (populating the `user_breeds` table). Build a form to create a new litter, capturing all fields specified in the `litters` schema (name, DOB, number of puppies, etc.). Include image upload to Supabase Storage for litter photos. Display a list of the breeder's existing litters with options to edit or update their status.",
        "testStrategy": "Log in as a verified breeder. Add a new breed to your profile and confirm it's saved. Create a new litter with multiple photos and verify it appears in the litter list. Edit the litter's details and confirm the changes are saved. Check Supabase tables (`user_breeds`, `litters`) to confirm data integrity.",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Breeder Dashboard: Build 'My Breeds' Management UI",
            "description": "Create a page or section in the breeder dashboard where verified breeders can add and remove the dog breeds they specialize in. This will interact with the `user_breeds` table.",
            "dependencies": [],
            "details": "Create a new route, likely `app/dashboard/breeds/index.tsx`. This component will fetch and display the breeder's currently associated breeds. Implement a multi-select component populated with all available breeds from the `breeds` table. Use the API route to update the `user_breeds` join table based on the breeder's selections.",
            "status": "pending",
            "testStrategy": "Log in as a breeder, navigate to the 'My Breeds' page. Add two breeds, save, and refresh to confirm they persist. Remove one breed and confirm the change is saved. Check the `user_breeds` table in Supabase directly."
          },
          {
            "id": 2,
            "title": "Breeder Dashboard: Create 'My Litters' List View",
            "description": "Develop the UI to display a list of a breeder's existing litters, providing a summary of each and entry points for creating new litters or editing existing ones.",
            "dependencies": [],
            "details": "Create a new route at `app/dashboard/litters/index.tsx`. This page will fetch and display all litters associated with the logged-in breeder. Use Chakra UI Card components to display each litter's summary (name, photo, DOB). Include a prominent 'Create New Litter' button linking to the form page. Each litter card will have an 'Edit' button linking to the pre-filled form for that specific litter.",
            "status": "pending",
            "testStrategy": "Once a litter can be created, log in as the breeder and navigate to the 'My Litters' page. Verify all created litters are displayed correctly with key information. Confirm the 'Create New Litter' and 'Edit' buttons navigate to the correct URLs."
          },
          {
            "id": 3,
            "title": "Breeder Dashboard: Implement Add/Edit Litter Form with Image Upload",
            "description": "Build the form for creating and editing a litter. This includes handling all fields from the `litters` schema and implementing multi-image uploads to Supabase Storage.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a dynamic route, e.g., `app/dashboard/litters/[litter_id]/index.tsx`, to handle both creating ('new') and editing (UUID). Use `react-hook-form` and `zod` for validation. The form must include a dropdown for 'breed' populated from the breeder's managed breeds (from subtask 1). Implement a multi-image uploader that sends files to a 'litter-photos' Supabase Storage bucket and stores the public URLs in the `litters` table. Create an API route for creating and updating litter data.",
            "status": "pending",
            "testStrategy": "Navigate from the litters list to create a new litter. Fill out the form, upload several photos, and save. Verify redirection and the new litter's appearance on the list. Edit the litter's details and confirm the changes persist. Check Supabase Storage for the uploaded files and the `litters` table for correct data."
          }
        ]
      },
      {
        "id": 8,
        "title": "Public-Facing Breed & Litter Discovery Page",
        "description": "Develop the public page where seekers can explore and filter available litters.",
        "details": "Create a Next.js page that fetches and displays all litters with `status = 'available'`. Implement filter controls for breed, location (simple text search for now), and size. Each litter card should display key information and link to a detailed view. Ensure data is fetched using RLS policies that only allow public viewing of available litters.",
        "testStrategy": "As a logged-out user, access the discovery page and verify that only litters marked 'available' are shown. Test the filtering functionality by breed and location. Ensure that clicking a litter card navigates to a placeholder detail page.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Seeker Application Submission Flow",
        "description": "Create the functionality for a seeker to submit an application for a specific litter.",
        "details": "On the litter detail page, add an 'Apply' button for logged-in seekers. This button should open a form where the seeker can provide their `application_data` (as a JSONB object). On submission, create a new record in the `applications` table with `status = 'submitted'`, linking the `seeker_id` and `litter_id`.",
        "testStrategy": "Log in as a seeker, find a litter, and click 'Apply'. Fill out the application form and submit it. Verify that a new record is created in the `applications` table in Supabase with the correct data and status. Ensure non-logged-in users are prompted to sign in.",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Breeder Dashboard: Inquiry & Application Management",
        "description": "Build the dashboard view for breeders to see and manage applications for their litters.",
        "details": "Create an 'Inquiries' or 'Applications' tab in the breeder dashboard. Fetch all applications related to the breeder's litters. Display them in a list or table format, showing seeker info, application status, and date. Implement actions to update the application status (e.g., 'Approve', 'Reject'). Add a deep link to open a WhatsApp conversation with the seeker.",
        "testStrategy": "Log in as the breeder who owns the litter from the previous test. Verify the new application appears in their dashboard. Change the application status and confirm the update in the database. Click the WhatsApp link and verify it attempts to open the correct chat.",
        "priority": "high",
        "dependencies": [
          7,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Seeker Dashboard: 'My Applications' Tracking",
        "description": "Create a dashboard page for seekers to track the status of their submitted applications.",
        "details": "Develop a 'My Applications' page for logged-in seekers. This page should fetch all applications where the `seeker_id` matches the current user's ID. Display each application's status (`Submitted`, `Approved`, etc.) and which litter it was for. The status should update in real-time if possible (or on page load).",
        "testStrategy": "Log in as the seeker who applied in the previous test. Go to the 'My Applications' page and verify the application is listed with the status 'Submitted'. Log in as the breeder, change the application status to 'Approved', then log back in as the seeker and confirm the status has updated on their dashboard.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Setup Notification Infrastructure with Supabase Edge Function",
        "description": "Create a reusable Supabase Edge Function to handle the logic for creating notification records and triggering external services.",
        "details": "Develop a new Edge Function (e.g., `process-notification`). This function will accept a payload (e.g., `userId`, `type`, `title`, `body`, `target`). Its job is to insert a new record into the `notifications` table. For now, it will just log the intent to send a push/WhatsApp message. This function will be invoked by database webhooks or directly from the client.",
        "testStrategy": "Deploy the Edge Function to Supabase. Manually invoke it using the Supabase client or a cURL request with a sample payload. Check the function logs to ensure it executed correctly and verify that a new record was created in the `notifications` table.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement 'New Application' Notification Trigger",
        "description": "Trigger a notification to the breeder when a seeker submits a new application for one of their litters.",
        "details": "Modify the application submission logic from Task 9. After successfully inserting a new record into the `applications` table, invoke the `process-notification` Edge Function (from Task 12). The payload should include the breeder's user ID, a notification type of 'new_application', and relevant details about the application.",
        "testStrategy": "Submit a new application as a seeker. Check the Edge Function logs to confirm it was invoked. Verify that a new record appears in the `notifications` table for the breeder, with the correct type and metadata linking to the new application.",
        "priority": "medium",
        "dependencies": [
          9,
          12
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-13T22:58:47.382Z",
      "updated": "2025-10-14T08:24:57.151Z",
      "description": "Tasks for master context"
    }
  }
}